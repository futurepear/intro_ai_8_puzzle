from board import Board
import numpy as np
import time
from agent import CB, NA, MT, BFS, a_star_search
"""
def main():

    for m in [10,20,30,40,50]:
        for seed in range(0,10):
            # Sets the seed of the problem so all students solve the same problems
            board = Board(m, seed)
            
            
            '''
            ***********************************************
            Solve the Board state here with A*
            ***********************************************
            '''
            print("Size of problem set:", m)
            function_set = [CB, NA, MT]
            for function in function_set: 
                start =  time.process_time()   
                result = a_star_search(board=board, heuristic=function)
                end =  time.process_time()
                solution_cpu_time = end-start
                print(f"Length of the solution found for {function}: {len(result)} ")
                print("Total CPU Time spent", solution_cpu_time) 
                print("\n\n")"""


def main():
    for m in [10,20,30,40,50]:
        for seed in range(0,10):
            print("Size of problem set:", m)
            function_set = [CB, NA, MT]

            for function in function_set: 
                board = Board(m, seed)   # reset board each run
                start = time.process_time()   
                result = a_star_search(board=board, heuristic=function)
                end = time.process_time()

                solution_cpu_time = end - start
                print(f"Length of the solution found for {function.__name__}: {len(result)}")
                print("Total CPU Time spent", solution_cpu_time)
                print("\n\n")

if __name__ == "__main__":
    main()

                           


           
         

'''
Note that the breadth first search can be viewed as A* search where the heuristic is zero. Hence we will comparing A* search with the following heuristic functions.

BF: Always returns 0 (breadth first search) 
MT: The number of misplaced tiles.
CB: The city-block distance or Manhattan distance.
NA: Your own heuristic which might not be admissible and specifically designed to reduce the amount of search.

To study how the amount of search varies with the problem difficulty, we will supply a program  _shuffle(Goal, m) which generates random solvable problems by  applying a random sequence of m moves to the goal state.

  For m= 10, 20, 30, 40 do  
    For n=10 random problems p generated by _Shuffle(Goal,m) 
	 For each algorithm/heuristic function A, 
            Solve p using A  
	    Record the length of the solution found, 
                 the number of nodes searched, 
                    and the total CPU time spent 

You might find that your algorithm is taking too long for some inputs and heuristics. Bound the time and/or the number of nodes searched to a maximum, and count how many problems are solved within that bound. Set the maximums based on your machine limitations and the time you have.

Submit a report with the following plots. Each plot should show one aspect of search as a function of m for the different methods (and heuristics). Indicate the search bounds you have used.



'''